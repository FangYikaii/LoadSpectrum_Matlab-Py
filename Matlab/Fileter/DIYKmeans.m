
%% ************************************************************************
%程序说明：
%   聚类算法
%   input_y为被处理的数据
%   m为循环次数
%   output_y为最后滤波效果
%更新说明：
%   2015年6月 by materjay at XMU
%% ************************************************************************

function [id,centers] = DIYKmeans(input_y, nkk)

a=input_y;
m=2;                %平滑因子，m=1等于没有分类（听说的）
[n,n1]=size(a);     %x为样本数，n1为样本维数
c_max=nkk;          %round(sqrt(n));分的类数
%**x为n*m的矩阵，行为样本的个数，列为样本的维数***
%**z为c*m的矩阵，行为类的个数，列为每个类的代表中心***
%**u为c*n的矩阵，行为类的个数，列为样本数，表示某样本对类的隶属度***
z=a(1:c_max,:);     %z初始化，x的前c_max个样本为中心。
u=zeros(c_max,n);   %u初始化
sumn=0;
sum0=zeros(1,n1);
sum1=0;
num=0;
e=1;                %精度初始化
while e>1e-6        %隶属度值不再发生变化时终止
    u0=u;           %记录前一个的u
    num=num+1;      %记录循环次数
    for i=1:c_max   %列更新u
        for k=1:n   %行更新u 
       %*************计算每个隶属度**********
            t0=norm(a(k,:)-z(i,:))^2;
            if t0==0%意味着某的数据就是类中心
               u(:,k)=0;%其他隶属度为0，自身为1.
               u(i,k)=1;   
            else
                for j=1:c_max
                    t1=norm(a(k,:)-z(j,:))^2;
                    t2=(t0/t1)^(2/(m-1));
                    sumn=sumn+t2;
                end
                u(i,k)=1/(sumn+0.00001);%得到第k的数据在第k类的隶属度
                sumn=0;
            end
        end
    end
%********************更新每类的代表中心z**********
    for i=1:c_max
        for k=1:n
            r1=u(i,k)^m;
            sum1=sum1+r1;
            sum0=sum0+a(k,:).*r1;    
        end
        z(i,:)=sum0/(sum1+0.000001);
        sum0=0;sum1=0;
    end  
%********************终止条件部分***********
    e=norm(u-u0)^2;
    if num>500%防止陷入死循环
        break;
    end
end
%*******************画出其中的二维图********************
% figure();
% plot(a(:,1),a(:,2),'*',z(:,1),z(:,2),'ro');
% 
% legend('原各段时间长度比例值','FCM聚类算法得到的类中心');
disp(z);
centers=z;
id=u;
end
